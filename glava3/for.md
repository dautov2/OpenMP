# for
##### **Бесконечный цикл — это дать сонному человеку треугольное одеяло.**
######Автор неизвестен
Директива **for** специфицирует итерационную конструкцию разделения работ, которая определяет область, в которой итерации соотвествующего цикла будут выполняться параллельно. Синтаксис конструкций **for** следующий:

```
#pragma omp for [клауза [ клауза]]
    цикл for
```
* **private (список)**   
* **firstprivate (список)**  
* **lastprivate (список)**
* **reduction (оператор : список)**
* **ordered**
* **schedule(вид [, длина_порции]) **
* **nowait**

Директива **for** накладывает ограничения на структуру соотвествующего цикла. Определенно, соотвествующий цикл должен иметь каноническую форму:

```
for ( выражение ; var логическая_операция b; приращение )
```
**выражение** одно из следующих:
```
    var = lb
    integer-type var = lb
```
**приращение** одно из следующих:
```
    ++var
    var++
    --var
    var--
    var += incr
    var -= incr
    var = var + incr
    var = incr + var
    var = var - incr 
```
**var** - целое со знаком. Если эта переменная предпологалась быть разделяемой, то она неявно становится приватной в течении выполнения цикла. Переменная не должна модефицироваться внутри тела оператора цикла. Если только переменная не определена как **lastprivate**, то после выполнения цикла её значение не определено.  

**логическая_операция** одна из следующих:
```
    <
    <=
    >
    >=
```
**lb, b и incr** инвариантные относительно цикла выражения. Вычисления выражения осуществляется без какой-либо синхронизации. Таким образом, любые побочные эффекты при вычислениях приводят к неопределённым результатам.

Следует отметить, каноническая форма позволяет вычислить число итераций цикла еще при входе в цикл. Это вычисление выполняется со значением типа переменной **var** после целочисленного переобразования типов(integral promontions). В частности, если значение **b - lb + incr** не может быть представлено в этом типе, то результат не определен. Так же **var** может быть итератором.

Для доступа к элементам некоторого множества элементов алгоритмы STL используют специальные объекты, называемые итераторами. В контейнерных типах STL они доступны через методы класса (например, begin() в шаблоне класса vector). Функциональные возможности указателей и итераторов близки, так что обычный указатель тоже может использоваться как итератор.

Клауза **schedule** определяет, каким образом итерации цикла делятся между потоками группы. Правильность программы не должно зависеть от того, какой поток выполняет конкретную итерацию. Значение **порции**, если оно определено, дожно быть инвариантным относительно цикла положительным целочисленным выражением. Вычисление выражения осуществляется без какой-либо синхронизации.  

**Вид** планирования может быть одним из следующих:
*  **static** 

Eсли определена клауза **schedule(static, длина_порции)** , то итерации делятся на порции длинной, равной **длина_порции**. Порции статически назначаются потокам в группе циклическим образом в порядке их номеров.
Если размер порции определён, то всё количество итераций делится на порции, которые приблизительно равны между собой, и каждому потоку назначается одна порция

*  **dynamic** 

Если определена клауза **schedule(dynamic, длина_порции)** , то порции итераций длиной **длина_порции** назначаются каждому потоку. Когда поток завершит присвоенную ей порцию 
*  **guided** 
*  **auto**
*  **runtime**
