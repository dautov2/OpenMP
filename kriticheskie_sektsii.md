# Критические секции

#####*В очередь, сукины дети, в очередь!*
###### Михаил Афанасьевич Булгаков. Собачье сердце


```
#pragma omp critical (name) 
```
С помощью директивы **critical**  мы указать участок кода, который может исполняться только одним потоком в один момент времени. Если однин из потоков начал выполнение критической секции с данным именем, то остальные потоки, начавшие выполнение этой же секции, будут заблокированы. Они будут ждать своей очереди. Как только первый поток завершит выполнение секции, один из заблокированных потоков войдет в нее. Выбор следующего потока, который будет выполнять критическую секцию, будет случайным. 
```
#include <omp.h>
main()
{
 int x;
 x = 0;
 
    #pragma omp parallel shared(x) 
    {
        #pragma omp critical 
        x = x + 1;
    }  
}
```


Критические секции могут быть именованными или не именованными. Хотя я вам советую присваивать имя критическим секциям. Это позволит 
Согласно стандарту все критические секции без имени, будут ассоциированы одним именем. 
Присвоение имени позволит вам одновременно выполнять две и более критические секции одновременно.

```
#pragma omp critical  
{
    doworkA();
}
#pragma omp critical 
{
    doworkB();
}
//Сначало будет завершено   doworkA() , а только потом doworkB()



#pragma omp critical (first) 
{
    doworkA();
}
#pragma omp critical (second) 
{
    doworkB();
}

//doworkA () и doworkB() будут выполнены одновременно 

```
Однако, есть случаи когда этого делать не стоит. К примеру, не стоит делать именованные критические секции для вывода данных на экран или же в один файл.
```
#pragma omp critical
{
	cout << "Привет от потока № " << omp_get_thread_num()<<endl;
}

//omp_get_thread_num() - библиотечная функция которая возвращает номер потока.
```
Обработка вложенных критических секций, может создать условие для наступления взаимной блокировки.

Критические секции удобный инструмент для разграничения доступа к общим данным. Однако, критическая секция привносит в параллельную программу последовательный код, что снижает эффективность. Следует применять только по необходимости.

Типичные ошибки:
* Использование critical когда эффективнее использовать atomic
    
* Большие объемы работ внутри critical секции

* Использование не нужной critical секции
