# Критические секции

#####*В очередь, сукины дети, в очередь!*
###### Михаил Афанасьевич Булгаков. Собачье сердце


```
#pragma omp critical (name) 
```
С помощью директивы **critical**  мы указать участок кода, который может исполняться только одним потоком в один момент времени. Если однин из потоков начал выполнение критической секции с данным именем, то остальные потоки, начавшие выполнение этой же секции, будут заблокированы. Они будут ждать своей очереди. Как только первый поток завершит выполнение секции, один из заблокированных потоков войдет в нее. Выбор следующего потока, который будет выполнять критическую секцию, будет случайным. 

Всегда именуйте критические секции.
Согласно стандарту все критические секции без имени, будут ассоциированы одним именем. 
Присвоение имени позволит вам одновременно выполнять две и более критические секции одновременно.

```
#pragma omp critical  
{
    doworkA();
}
#pragma omp critical 
{
    doworkB();
}
//Сначало будет завершено   doworkA() , а только потом doworkB()



#pragma omp critical (first) 
{
    doworkA();
}
#pragma omp critical (second) 
{
    doworkB();
}

//doworkA () и doworkB() будут выполнены одновременно 

```
Однако, есть случаи когда этого делать не стоит. К примеру, не стоит делать именованные критические секции для вывода данных на экран или же в один файл.
```
#pragma omp critical
{
	cout << "Привет от потока № " << omp_get_thread_num()<<endl;
}

//omp_get_thread_num() - библиотечная функция которая возвращает номер потока.
```
Обработка вложенных критических секций, может создать условие для наступления взаимной блокировки.

Критические секции удобный инструмент для разграничения доступа к общим данным. Однако, критическая секция привносит в параллельную программу последовательный код, что снижает эффективность. Следует применять только по необходимости.

Типичные ошибки:
* Использование critical когда эффективнее использовать atomic
    
* Большие объемы работ внутри critical секции

* Использование не нужной critical секции
